For our simple shell project, we will create a command-line interface that allows users to interact with the underlying operating system. The shell will act as a bridge between the users and the operating system, receiving their commands and executing them.

In the interactive shell, we will provide users with a prompt where they can enter commands. They will see a cursor awaiting their input. Whenever a user types a command and presses enter, we will parse the command and execute the corresponding program or built-in command. If there is any output or relevant information from the execution, we will display it for the user. Users can keep entering commands, and we will continue to process them until they decide to exit. We will also support useful features like command history, where users can navigate through their previous commands using the arrow keys, as well as tab completion to help them complete command or file names quickly. Additionally, we will handle signal handling, so if a user presses Ctrl+C to interrupt a running command, we will respond accordingly.

In the non-interactive shell, we will read commands from a file or a script instead of directly from the user. This will allow users to automate tasks or execute a series of commands without manual intervention. We will execute the commands one by one, sequentially, and display the output of each command or write it to a file for later use. If any errors occur during command execution, we will gracefully handle them and inform the users about the encountered issues. This way, users can rely on the non-interactive shell to run batch scripts or perform automated tasks on their operating system.

Throughout the project, we will ensure that the shell supports essential commands like executing programs, changing directories (cd), listing files (ls), creating directories (mkdir), and more. We will also enable features like piping and redirection, which allow users to chain commands together or redirect input/output as needed. If a command fails or encounters an issue, we will display meaningful error messages to keep the users informed. Moreover, we can customize the shell to include aliases, so users can create shortcuts for frequently used commands, and environment variables to enhance their experience.

As we progress, we can extend the functionality of the shell by implementing additional built-in commands or integrating external programs and libraries to meet users' specific needs
